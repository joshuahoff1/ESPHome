esphome:
  name: office-dashboard
  friendly_name: Office Dashboard
  #build_path: "../config/esphome/${name}_build"

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "h/cXlhKoimR10oZ1jxSk+ptejmAdbcDvqABB1oRXBq4="
  actions:
    - action: get_events
      variables:
        my_events: string
      then:
        - text_sensor.template.publish:
            id: all_events
            state: !lambda |- 
              return my_events;

ota:
  - platform: esphome
    password: "5232bd64bcb691949f3d85b6ae70872b"

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: first_update_done
    type: bool
    restore_value: no
    initial_value: "false"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  manual_ip: 
    static_ip: 192.168.86.112
    gateway: 192.168.86.1
    subnet: 255.255.255.0
  on_connect:
    then:
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;

   # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Office-Dashboard"
    password: "pYQdbM3UU28o"

captive_portal:

# add json parsing support
json:

sun:
  latitude: 38.5509
  longitude: -90.2764
  id: sun_sun
      

# Here is deep sleep part
deep_sleep:
  id: deep_sleep_1

script:
  - id: update_display
    then:
      - component.update: my_display


interval:
  # Condition: wifi connected && data retrieved && first time
  - interval: 10s  # Check every 10 second
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - lambda: "return !id(ha_calendar_event_1).state.empty();"
              - lambda: "return !id(first_update_done);"
          then:
            - lambda: |-
                ESP_LOGD("Display", "Updating Display...");
            - script.execute: update_display  # Refresh immediately
            - lambda: "id(first_update_done) = true;"


image:
  - file: image/wifi.jpg
    type: BINARY
    id: esphome_logo
    resize: 400x240
    invert_alpha: true

# Connect to Home Assistant to get time
time:
  - platform: sntp
    id: sntp_time
    timezone: US/Central
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org
  - platform: homeassistant
    id: homeassistant_time
    on_time: 
      - seconds: 0
        minutes: '*'
        hours: 7-20
        then:
          - component.update: my_display
      #deep sleep at night.
      - hours: 21
        then:
          - delay: 10s
          - deep_sleep.enter:
              id: deep_sleep_1
              sleep_duration: !lambda "return 1000 * 60 * 60 * 11;" #11 hours

text_sensor:
  - platform: homeassistant
    id: ha_calendar_event_1
    entity_id: calendar.philiph1352000_gmail_com
    attribute: "message"
  - platform: homeassistant
    id: ha_calendar_start_time_1
    entity_id: calendar.philiph1352000_gmail_com
    attribute: "start_time"
  - platform: homeassistant
    id: ha_calendar_end_time_1
    entity_id: calendar.philiph1352000_gmail_com
    attribute: "end_time"

  - platform: homeassistant
    id: ha_calendar_event_2
    entity_id: calendar.joshua_hoff1_gmail_com
    attribute: "message"
  - platform: homeassistant
    id: ha_calendar_start_time_2
    entity_id: calendar.joshua_hoff1_gmail_com
    attribute: "start_time"
  - platform: homeassistant
    id: ha_calendar_end_time_2
    entity_id: calendar.joshua_hoff1_gmail_com
    attribute: "end_time"

  - platform: template
    id: all_events

  - platform: homeassistant
    entity_id: weather.forecast_home
    id: myWeather
  - platform: homeassistant
    entity_id: weather.forecast_home
    id: temp
    attribute: "temperature"
  - platform: homeassistant
    entity_id: weather.forecast_home
    id: humi
    attribute: "humidity"
  - platform: homeassistant
    entity_id: weather.forecast_home
    id: uv
    attribute: "uv_index"

  # Sunrise
  - platform: sun
    type: sunrise
    id: sun_sunrise
    format: "%I:%M"
  # Sunset
  - platform: sun
    type: sunset
    id: sun_sunset
    format: "%I:%M"

  - platform: homeassistant
    entity_id: media_player.kitchen_display
    id: office_display_playing #off, playing, paused, buffering, idle
  - platform: homeassistant
    entity_id: media_player.kitchen_display
    id: office_display_song
    attribute: "media_title"
    on_value: 
      then:
        - component.update: my_display
        
  - platform: homeassistant
    entity_id: media_player.kitchen_display
    id: office_display_artist
    attribute: "media_artist"

sensor:
  - platform: homeassistant
    entity_id: sensor.office_weather_temperature
    id: office_temp
  - platform: homeassistant
    entity_id: sensor.living_room_weather_temperature
    id: living_room_temp

font:
  - file: "fonts/GoogleSans-Medium.ttf"
    id: font_large
    size: 50   
  - file: "fonts/GoogleSans-Bold.ttf"
    id: font_large_bold
    size: 50
  - file: "fonts/GoogleSans-Bold.ttf"
    id: font_xlarge_bold
    size: 70
  - file: "fonts/GoogleSans-Medium.ttf"
    id: font_small
    size: 25   
  - file: "fonts/GoogleSans-Bold.ttf"
    id: font_small_bold
    size: 25

  - file: 'fonts/materialdesignicons-webfont.ttf' # Directory to save ttf file
    id: font_mdi_large
    size: 130
    glyphs: &mdi-weather-glyphs # https://pictogrammers.com/library/mdi/
      - "\U000F050F" # Thermometer
      - "\U000F0F54" #home temp
      - "\U000F18D6" #sun temp
      - "\U000F058E" # Humidity
      - "\U000F0594" # clear-night
      - "\U000F0590" # cloudy
      - "\U000F0595" # partlycloudy
      - "\U000F0591" # fog      
      - "\U000F0592" # hail
      - "\U000F0593" # lightning
      - "\U000F067E" # lightning-rainy
      - "\U000F0596" # pouring
      - "\U000F0597" # rainy
      - "\U000F0F36" # snowy
      - "\U000F067F" # snowy-rainy
      - "\U000F0599" # sunny
      - "\U000F059D" # windy
      - "\U000F059E" # windy-variant
      - "\U000F0F38" # exceptional
      - "\U000F059B" # sunset
      - "\U000F059C" # sunrise 
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_weather # Copy the above icon and change the size to 40
    size: 200
    glyphs: *mdi-weather-glyphs
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: img_font_small # Copy the above icon and change the size to 40
    size: 30
    glyphs: *mdi-weather-glyphs

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO2
    model: 7.50inv2p
    full_update_every: 30
    update_interval: never
    lambda: |-
      if(id(wifi_status) == 0){
        it.image(180, 0, id(esphome_logo));
        it.printf(400, 300, id(font_large_bold), TextAlign::TOP_CENTER,  "WI-FI CONNECTING");
      }else{
        //weather icon mappings
        std::map<std::string, std::string> weather_icon_map
        {
          {"clear-night", "\U000F0594"},
          {"cloudy", "\U000F0590"},
          {"partlycloudy", "\U000F0595"},
          {"fog", "\U000F0591"},
          {"hail", "\U000F0592"},
          {"lightning", "\U000F0593"},
          {"lightning-rainy", "\U000F067E"},
          {"pouring", "\U000F0596"},
          {"rainy", "\U000F0597"},
          {"snowy", "\U000F0F36"},
          {"snowy-rainy", "\U000F067F"},
          {"sunny", "\U000F0599"},
          {"windy", "\U000F059D"},
          {"windy-variant", "\U000F059E"},
          {"exceptional", "\U000F0F38"}
        };
          
        std::map<std::string, std::string> weather_text_map
        {
          {"clear-night", "Clear Night"},
          {"cloudy", "Cloudy"},
          {"partlycloudy", "Partly Cloudy"},
          {"fog", "Fog"},
          {"hail", "Hail"},
          {"lightning", "Lightning"},
          {"lightning-rainy", "Rain with Lightning"},
          {"pouring", "Pouring Rain"},
          {"rainy", "Light Rain"},
          {"snowy", "Snow"},
          {"snowy-rainy", "Snow/Rain"},
          {"sunny", "Sunny"},
          {"windy", "Windy"},
          {"windy-variant", "Windy"},
          {"exceptional", "Dangerous Conditions"}
        };



        //LEFT SIDE
        // Draw Date and Time
        auto time_now = id(homeassistant_time).now();
        it.strftime(370/2, 40, id(font_small), TextAlign::TOP_CENTER, "%A %B %d ", time_now);
        it.strftime(370/2, 80, id(font_large_bold), TextAlign::TOP_CENTER, "%I:%M %p", time_now); // Convert to 12-hour format

        // Sunset/Sunrise
        int sun_y = 140;
        int sun_x = 370/2;
        // sunrise
        if(id(sun_sunrise).has_state ()) {
          it.printf(sun_x - 120, sun_y , id(img_font_small), "\U000F059C");
          it.printf(sun_x - 90, sun_y, id(font_small), "%s", id(sun_sunrise).state.c_str());
        }
        // sunset
        if(id(sun_sunset).has_state ()) {
          it.printf(sun_x + 90, sun_y , id(img_font_small), "\U000F059B");
          it.printf(sun_x + 30, sun_y, id(font_small), "%s", id(sun_sunset).state.c_str());
        }    

        // Draw weather images with text
        int weather_icon_x = 370*.28, weather_icon_y = 270;
        std::string weather_string = id(myWeather).state.c_str();
        it.printf(weather_icon_x, weather_icon_y, id(font_mdi_large), TextAlign::CENTER, weather_icon_map[weather_string].c_str());
        // Weather text
        //it.printf(weather_icon_x, 300, id(font_small), TextAlign::TOP_CENTER, "%s", weather_text_map[weather_string].c_str());

        it.printf(370*.72, weather_icon_y, id(font_xlarge_bold), TextAlign::CENTER, "%s°F", id(temp).state.c_str());
        
        // Temperature
        int y = 370;
        // outside
        //it.printf(40, y, id(img_font_small), "\U000F18D6");
        //it.printf(80, y, id(font_small_bold), "%s°F", id(temp).state.c_str());
        // inside office
        it.printf(150, y, id(img_font_small), "\U000F0F54");
        it.printf(190, y, id(font_small_bold), "%.0f°F", id(office_temp).state);
        // inside living room
        it.printf(40, y, id(img_font_small), "\U000F0F54");
        it.printf(80, y, id(font_small_bold), "%.0f°F", id(living_room_temp).state);
        
        // Humidity
        y = 400;
        it.printf(40, y, id(img_font_small), "\U000F058E");
        // Get humidity data
        it.printf(80, y, id(font_small_bold), "%s%%", id(humi).state.c_str());


        // VERTICAL SEPARATOR
        it.filled_rectangle(370, 30, 5, 430);

      
        // RIGHT SIDE
        it.printf(600, 40, id(font_large_bold), TextAlign::TOP_CENTER, "Calendar");

        //attempt at reading full day of events
        std::string eventList = id(all_events).state;
        std::replace(eventList.begin(), eventList.end(), '\'', '"');
        if (!eventList.empty()){
          //ESP_LOGD("state", "%s", eventList.c_str());
          json::parse_json(eventList, [](JsonObject root) -> bool {
            bool hasProp = root.containsKey("start_date");
            ESP_LOGD("hasProp", "result: %s", hasProp ? "true" : "false");
            return hasProp;
          });
        }


        // Define event structure
        struct Event {
            std::string message;
            std::string start_time;
            std::string end_time;
            time_t start_timestamp;
        };

        // Parse time string to time_t (UNIX timestamp)
        auto parse_time = [](const std::string &time_str) -> time_t {
            struct tm timeinfo = {};
            if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr) {
                return 0;  // Invalid time
            }
            return mktime(&timeinfo);
        };

        // Create event list
        std::vector<Event> events = {
            {id(ha_calendar_event_1).state, id(ha_calendar_start_time_1).state, id(ha_calendar_end_time_1).state, parse_time(id(ha_calendar_start_time_1).state)},
            {id(ha_calendar_event_2).state, id(ha_calendar_start_time_2).state, id(ha_calendar_end_time_2).state, parse_time(id(ha_calendar_start_time_2).state)}
        };
        ESP_LOGD("myCalendar", "Start Time: %s -> %ld", id(ha_calendar_start_time_1).state.c_str(), parse_time(id(ha_calendar_start_time_1).state));

        // Filter invalid events (start_timestamp == 0)
        events.erase(std::remove_if(events.begin(), events.end(), [](const Event &e) { return e.start_timestamp == 0; }), events.end());

        // Sort by `start_timestamp` (earliest to latest)
        std::sort(events.begin(), events.end(), [](const Event &a, const Event &b) {
            return a.start_timestamp < b.start_timestamp;
        });

        // Define a function to format time
        auto format_time = [](std::string time_str) -> std::string {
            struct tm timeinfo;
            if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr) {
                return "Invalid";
            }
            char buffer[10];
            strftime(buffer, sizeof(buffer), "%I:%M%p", &timeinfo); // Convert to 12-hour format
            return std::string(buffer);
        };
        // Parse date
        auto format_date = [](const std::string &time_str) -> std::string {
            struct tm timeinfo = {};
            if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr) {
                return "Invalid";
            }
            char buffer[6];  // Need to store "MM-DD\0"
            strftime(buffer, sizeof(buffer), "%m-%d", &timeinfo);
            return std::string(buffer);
        };

        // Draw events
        int even_x_start_offset = 400;
        int even_y_start_offset = 100;
        for (const auto &event : events) {
          if(even_y_start_offset >= 420){
            break;
          }

          // Format time
          std::string formatted_date = format_date(event.start_time);
          std::string formatted_start_time = format_time(event.start_time);
          std::string formatted_end_time = format_time(event.end_time);

          // Combine time range string
          std::string time_range = formatted_start_time + " - " + formatted_end_time;
          time_range = formatted_date + "  " + time_range;
          if(formatted_start_time == "Invalid" || formatted_end_time == "Invalid"){
            time_range.clear();
          }
          // Display time range, e.g., "10:00AM - 11:00AM"
          it.printf(even_x_start_offset, even_y_start_offset, id(font_small), "%s", time_range.c_str());
          even_y_start_offset += 30;
          // Display event name
          it.printf(even_x_start_offset, even_y_start_offset, id(font_small), "%s", event.message.c_str());
          even_y_start_offset += 40;
        }

        // Current media
        if(id(office_display_playing).state == "playing"){
          it.printf(400, 370, id(font_small_bold), "%s", id(office_display_song).state.c_str());
          it.printf(400, 400, id(font_small_bold), "%s", id(office_display_artist).state.c_str());
        }
      }
